<?php

// pnuser.php,v 1.18 2007/03/16 01:58:56 paustian Exp
// ----------------------------------------------------------------------
// PostNuke Content Management System
// Copyright (C) 2002 by the PostNuke Development Team.
// http://www.postnuke.com/
// ----------------------------------------------------------------------
// Based on:
// PHP-NUKE Web Portal System - http://phpnuke.org/
// Thatware - http://thatware.org/
// ----------------------------------------------------------------------
// LICENSE
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License (GPL)
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// To read the license please visit http://www.gnu.org/copyleft/gpl.html
// ----------------------------------------------------------------------
// Original Author of file: Timothy Paustian
// Purpose of file:  Book user display functions
// ----------------------------------------------------------------------

function book_user_() {
    return book_user_main();
}

/**
 * the main user function
 * This function is the default function, and is called whenever the module is
 * initiated without defining arguments.  As such it can be used for a number
 * of things, but most commonly it either just shows the module menu and
 * returns or calls whatever the module designer feels should be the default
 * function (often this is the view() function)
 */
function book_user_main() {
    // Create output object - this object will store all of our output so that
    // we can return it easily when required
    $pnRender = pnRender::getInstance('Book', false);

    // Security check
    if (!SecurityUtil::checkPermission('Book::', '::', ACCESS_READ)) {
        return LogUtil::registerPermissionError();
    }

    // For this function we want the user to see the books that are available for display
    //Initially I am going to make this just list the books.
    //I will get fancier as time goes on, adding cover art and such.


    //A list of books
    $bookItems = pnModAPIFunc('Book', 'user', 'getall', array ('startnum' => 1));

    if ($bookItems == 0) {
        //if we dont' have a book, then you
        //cannot have chapters
        return LogUtil::registerError(__('There are no books to display'));
    }
    //I now need to convert this to a new array
    $bookTitleArray = array ();
    foreach ($bookItems as $item) {

        if (SecurityUtil::checkPermission('Book::', "$item[book_id]::.*", ACCESS_READ)) {
            $bookTitleArray[] = array ('url' => pnModURL('Book', 'user', 'toc', array ('book_id' => $item['book_id'])), 'title' => $item['book_name']);
        } else {
            $bookTitleArray[] = array ('title' => $item['title']);
        }
    }

    // Return the output that has been generated by this function
    $pnRender->assign('book_names', $bookTitleArray);

    return $pnRender->fetch('book_user_main.htm');
}

function book_user_toc($args) {
    // Get parameters from whatever input we need.
    $book_id = FormUtil::getPassedValue('book_id', isset($args['book_id']) ? $args['book_id'] : null);

    // if this get called without a
    if (!isset ($book_id)) {
        $book_id = 4;
    }
    if (!is_numeric($book_id)) {
        return LogUtil::registerArgsError();
        ;
    }

    $book = pnModAPIFunc('Book', 'user', 'get', array ('book_id' => $book_id));

    //Make sure the book exists
    if (!$book) {
        return LogUtil::registerError(__('That book does not exist.'));
    }
    // The API function is called.  The arguments to the function are passed in
    // as their own arguments array
    $chapters = pnModAPIFunc('Book', 'user', 'getallchapters', array ('book_id' => $book_id));

    // The return value of the function is checked here, and if the function
    // suceeded then an appropriate message is posted.
    if (!$chapters) {
        return LogUtil::registerError(__('No chapters are present'));
    }

    // Create output object
    $pnRender = pnRender::getInstance('Book', false);

    // Loop through each chapter and extract the text we need for display.
    //$toc_string = "<ol>\n";
    $chapter_data = array ();
    if (SecurityUtil::checkPermission('Book::Chapter', "$book[book_id]::.*", ACCESS_ADMIN)) {
        $pnRender->assign('show_internals', true);

    }

    foreach ($chapters as $chapter_item) {
        $chap_id = $chapter_item['chap_id'];
        if ($chapter_item['chap_number'] > 0) {
            $articles = pnModAPIFunc('Book', 'user', 'getallarticles', array ('chap_id' => $chap_id, 'get_content' => false));
            $art_array = array ();
            foreach ($articles as $article_item) {
                if ($article_item['art_number'] > 0) {
                    $art_array[] = $article_item;
                }
            }

            $pnRender->assign('chapter', $chapter_item);
            $pnRender->assign('articles', $art_array);
            $pnRender->caching = false;
            if (SecurityUtil::checkPermission('Book::Chapter', "$book[book_id]::$chapter_item[chap_id]", ACCESS_READ)) {
                $chapter_data[] = $pnRender->fetch("book_user_toc_row.htm");
            } else {
                $chapter_data[] = $pnRender->fetch("book_user_toc_row_overview.htm");
            }
            $pnRender->caching = true;
        }
    }

    // The chapters that are displayed on this overview page depend on the individual
    // user permissions. Therefor, we can not cache the whole page.
    // The single entries are cached, though.
    $pnRender->caching = false;

    // Display the entries
    $pnRender->assign('chapters', $chapter_data);
    $pnRender->assign('book', $book);

    return $pnRender->fetch('book_user_toc.htm');
}

function book_user_shorttoc($args) {
    // Get parameters from whatever input we need.
    $book_id = FormUtil::getPassedValue('book_id', isset($args['book_id']) ? $args['book_id'] : null);
    $art_id = FormUtil::getPassedValue('art_id', isset($args['art_id']) ? $args['art_id'] : null);
    // if this get called without a
    if (!isset ($book_id)) {
        if (($args['book_id'] != "")) {
            $book_id = $args['book_id'];
        } else {
            return "";
        }
    }

    if (!is_numeric($book_id)) {
        return LogUtil::registerArgsError();
        ;
    }

    // The API function is called.  The arguments to the function are passed in
    // as their own arguments array
    $chapters = pnModAPIFunc('Book', 'user', 'getallchapters', array ('book_id' => $book_id));

    // The return value of the function is checked here, and if the function
    // suceeded then an appropriate message is posted.
    if (!$chapters) {
        return LogUtil::registerError(__('There are no chapters.'));
    }

    // Create output object
    $pnRender = pnRender::getInstance('Book', false);

    // Loop through each chapter and extract the text we need for display.
    //$toc_string = "<ol>\n";
    $chapter_data = array ();
    if (SecurityUtil::checkPermission('Book::Chapter', '.*::.*', ACCESS_ADMIN)) {
        $pnRender->assign('show_internals', true);

    }

    foreach ($chapters as $chapter_item) {
        $chap_id = $chapter_item['chap_id'];
        if ($chapter_item['chap_number'] > 0) {
            if (SecurityUtil::checkPermission('Book::Chapter', "$book_id::$chapter_item[chap_id]", ACCESS_OVERVIEW)) {
                $chapter_item['chap_name'] = myTruncate2($chapter_item['chap_name'], 25);
                $chapter_data[] = $chapter_item;
            }
        }
    }
    //grab the username and place it in the code
    $user_name = pnUserGetVar('uname');

    if($user_name !== '') {
        $pnRender->assign('loggedIn', "doIT");
    }
    $pnRender->assign('chapters', $chapter_data);
    $pnRender->assign('art_id', $art_id);

    $pnRender->caching = false;
    $text = $pnRender->fetch('book_user_shorttoc.htm');

    return $text;
}

// Original PHP code by Chirp Internet: www.chirp.com.au
// Please acknowledge use of this code by including this header.

function myTruncate2($string, $limit, $break=" ", $pad="...") {
    // return with no change if string is shorter than $limit
    if(strlen($string) <= $limit) return $string;

    $string = substr($string, 0, $limit);
    if(false !== ($breakpoint = strrpos($string, $break))) {
        $string = substr($string, 0, $breakpoint);
    }

    return $string . $pad;
}

/**
 * view items
 * This is a standard function to provide an overview of all of the items
 * available from the module.
 */
function book_user_view($args) {
    // Get parameters from whatever input we need.
    $book_id = FormUtil::getPassedValue('book_id', isset($args['book_id']) ? $args['book_id'] : null);

    // if this get called without a
    if (!isset ($book_id)) {
        $book_id = 1;
    }
    if (!is_numeric($book_id)) {
        return LogUtil::registerArgsError();
        ;
    }

    $book = pnModAPIFunc('Book', 'user', 'get', array ('book_id' => $book_id));

    //Make sure the book exists
    if (!$book) {
        return LogUtil::registerError(__('That book does not exist.'));
    }
    // The API function is called.  The arguments to the function are passed in
    // as their own arguments array
    $chapters = pnModAPIFunc('Book', 'user', 'getallchapters', array ('book_id' => $book_id));

    // The return value of the function is checked here, and if the function
    // suceeded then an appropriate message is posted.
    if (!$chapters) {
        return LogUtil::registerError(__('There are no chapters for this book.'));
    }

    // Create output object
    $pnRender = pnRender::getInstance('Book', false);

    // Loop through each chapter and extract the text we need for display.
    $chapter_titles = array ();
    $chapter_ids = array ();
    $chap_number = array ();
    //right now this is not working with the permission I need to test
    foreach ($chapters as $chapter_item) {
        if (SecurityUtil::checkPermission('Book::Chapter', "$book[book_id]::$chapter_item[chap_id]", ACCESS_OVERVIEW)) {

            $chapter_titles[] = $chapter_item['chap_name'];
            $chapter_ids[] = $chapter_item['chap_id'];
            $chap_number[] = $chapter_item['chap_number'];
        }
    }

    // The chapters that are displayed on this overview page depend on the individual
    // user permissions. Therefor, we can not cache the whole page.
    // The single entries are cached, though.
    $pnRender->caching = false;

    // Display the entries
    $pnRender->assign('titles', $chapter_titles);
    $pnRender->assign('ids', $chapter_ids);
    $pnRender->assign('chap_number', $chap_number);
    $pnRender->assign('book', $book['book_name']);

    return $pnRender->fetch('book_user_view.htm');
}

/**
 * display item
 * This is a standard function. We use it to provide all the chatpers in a book and links
 * to the articles within that chapter
 * available from the module.
 */
function book_user_display($args) {
    // Security check -
    if (!SecurityUtil::checkPermission('Book::', '::', ACCESS_OVERVIEW)) {
        return LogUtil::registerPermissionError();
    }
    // Get parameters
    $chap_id = FormUtil::getPassedValue('chap_id', isset($args['chap_id']) ? $args['chap_id'] : null);
    // User functions of this type can be called by other modules.
    extract($args);

    if (!is_numeric($chap_id)) {
        return LogUtil::registerArgsError();
        ;
    }

    // Create output object
    $pnRender = pnRender::getInstance('Book', false);
    // The item ID is appropriate to be used as the cache ID.
    $pnRender->cache_id = $chap_id;

    //get the chapter title
    $chapter = pnModAPIFunc('Book', 'user', 'getchapter', array ('chap_id' => $chap_id));
    if (!$chapter) {
        return LogUtil::registerError(__('There are no chapters.'));
    }
    $pnRender->assign('chapter', $chapter['chap_name']);
    //Get the article data. We do not need the content information
    //so send that along.

    $articles = pnModAPIFunc('Book', 'user', 'getallarticles', array ('chap_id' => $chap_id, 'get_content' => false));

    //Did we get the chatpers data?
    if (!$articles) {
        return LogUtil::registerError(__('There are no articles.'));
    }
    //extract the articles to display.
    $art_titles = array ();
    $art_ids = array ();
    $section_num = array ();
    $i = 1;
    foreach ($articles as $article_item) {
        $art_titles[] = $article_item['title'];
        $art_ids[] = $article_item['art_id'];
        $section_num[] = "$chapter[chap_number]"."-".$i;
        $i ++;
    }

    $pnRender->assign('titles', $art_titles);
    $pnRender->assign('ids', $art_ids);
    $pnRender->assign('section_number', $section_num);
    if (SecurityUtil::checkPermission('Book::Chapter', "$book_id::$chapter[chap_id]", ACCESS_READ)) {
        //produce links to articles for those that can read
        $render_output = $pnRender->fetch('book_user_display.htm');
    } else {
        //only allow access to the titles of the articles
        //and not links to them
        $render_output = $pnRender->fetch('book_user_displayoverview.htm');
    }

    // Return the output that has been generated by this function
    return $render_output;
}

/**
 * Display an article
 *
 */
function book_user_displayarticle($args) {
     // Get parameters
    $art_id = FormUtil::getPassedValue('art_id', isset($args['art_id']) ? $args['art_id'] : null);
    $do_glossary = FormUtil::getPassedValue('do_glossary', isset($args['do_glossary']) ? $args['do_glossary'] : null);
    
    if(!isset($do_glossary)){
        $do_glossary = true;
    }
    pnModFunc('book', 'user', 'checkuserstatus');

    $pnRender = pnRender::getInstance('Book');

    //get the chapter title
    $article = pnModAPIFunc('Book', 'user', 'getarticle', array ('art_id' => $art_id));
    $chapter = pnModAPIFunc('Book', 'user', 'getchapter', array ('chap_id' => $article['chap_id']));

    // Security check -
    if (!SecurityUtil::checkPermission('Book::Chapter', "$article[book_id]::$article[chap_id]", ACCESS_READ)) {
        return LogUtil::registerPermissionError();
    }
    $content = $article['contents'];
    //Now add the highlights if necessary
    $uid = pnUserGetVar('uid');
    if($uid != "") {
        $highlights = pnModAPIFunc('Book',
                'user',
                'gethighlights', array ('uid' => $uid, 'art_id' => $art_id));
        if($highlights) {
            $content = process_highlights($highlights, $content);
        }
    }
    if($article['next'] == 0){
        //no link assigned, lets see if we can find the next one
        $next_art =  pnModAPIFunc('Book', 'user', 'getarticlebyartnumber', array ('art_number' => $article['art_number'] + 1, 'chap_id' => $article['chap_id']));
        $article['next'] = $next_art['art_id'];
    }
    if( ($article['prev'] == 0) || ($article['art_numner'] != 1) ){
        //no link assigned, lets see if we can find the next one
        $prev_art =  pnModAPIFunc('Book', 'user', 'getarticlebyartnumber', array ('art_number' => $article['art_number'] - 1, 'chap_id' => $article['chap_id']));
        $article['prev'] = $prev_art['art_id'];
    }
    $pnRender->assign('art_id', $article['art_id']);
    $pnRender->assign('chap_id', $article['chap_id']);
    $pnRender->assign('section_id', $article['art_number']);
    $pnRender->assign('chap_number', $chapter['chap_number']);
    $pnRender->assign('content', $content);
    $pnRender->assign('counter', $article['counter']);
    $pnRender->assign('title', $article['title']);
    $pnRender->assign('next', $article['next']);
    $pnRender->assign('prev', $article['prev']);
    $pnRender->assign('book_id', $article['book_id']);
    //this code is used for the hook
    $return_url = pnModURL('Book', 'user', 'displayarticle', array ('art_id' => $art_id));
    $pnRender->assign('returnurl', $return_url);

    //call the user api to increment the counter
    if (!pnModAPIFunc('Book', 'user', 'setcounter', array ('art_id' => $art_id, 'counter' => $article['counter']))) {
        return LogUtil::registerError(__('Count not set book counter.'));
    }
    if (SecurityUtil::checkPermission('Book::Chapter', "$article[book_id]::$article[chap_id]", ACCESS_EDIT)) {
        $pnRender->assign('show_internals', true);

    }
    
    $return_text = $pnRender->fetch('book_user_displayarticle.htm');

    $return_text = book_user_addfigures($return_text);

    //work in the glossary items
    if($do_glossary){
        $return_text = book_user_add_glossary_defs(array('in_text' =>$return_text));
    }

    return $return_text;
}

//book_user_addfigures
//I factored this out of the above so that I could call it from the admin
//code for exporting the chapters.
function book_user_addfigures($ioText){
    //substitute all the figures
    $pattern = "|<!--\(Figure ([0-9]{1,2})-([0-9]{1,3})-([0-9]{1,3})\)-->|";
    $ioText = preg_replace_callback($pattern, "book_user_inlinefigures", $ioText);
    //this is a legacy pattern
    $pattern = "|{Figure ([0-9]{1,2})-([0-9]{1,3})-([0-9]{1,3}).*}|";
    $ioText = preg_replace_callback($pattern, "book_user_inlinefigures", $ioText);
    return $ioText;
}

/**
 * book_add_glossary_defs
 *
 * Given some text, insert the glossary definitions.
 *
 * @param inText - the text to add glossary definitions to
 * @return retText - the text with glossary definitions addeed
 *
 */

function book_user_add_glossary_defs($args){
    $in_text = $args['in_text'];
    // Security check - important to do this as early on as possible to
    // avoid potential security holes or just too much wasted processing
    if (!SecurityUtil::checkPermission('Book::', "::", ACCESS_READ)) {
        LogUtil::registerPermissionError();
        return false;
    }

    //all the work is done in this funcion
    $pattern = "|<a class=\"glossary\">(.*?)</a>|";
    $ret_text = preg_replace_callback($pattern, '_glossary_add', $in_text);

    return $ret_text;
}

/**
 *  _glossary_add
 * This is a callback function to convert glossary terms into their definitions.
 * I am added it here and not into the text to keep from polluting the text 
 * with glossary definitions.
 * 
 * @param $matches
 * @return the match text to insert 
 */
function _glossary_add($matches) {
    $term = $matches[1];
    $item = array();
    $pntable =& pnDBGetTables();
    $glossaryList = &$pntable['book_glossary_column'];
    $where ="WHERE $glossaryList[term]='" . DataUtil::formatForStore($term) . "'";
    $item = DBUtil::selectObject('book_glossary', $where);

    if ($item === false) {
        //This did not work, try searching for match instead
        $where = "WHERE $glossaryList[term] LIKE '" . DataUtil::formatForStore($term) . "%'";
        $item = DBUtil::selectObject('book_glossary', $where);
    }
    // Check for an error and if so
    //just return. This is not an error, we just won't replace it
    //$matches[0] contains the found string, so we just return the found
    //string.
    if($item === false) {
        return $matches[0];
    }
    $definition = $item['definition'];
    $lcterm =  strtolower($term);
    $URL = DataUtil::formatForDisplayHTML(pnModURL('Book', 'user', 'displayglossary')) . "#$lcterm";
    $ret_text =  "<a class=\"glossary\" href=\"$URL\" onmouseover=\"return escape('$definition')\">$term</a>";
    return $ret_text;
}


/**
 * process_highlights
 *
 * Add highlight to the incomping text, based upon the offsets in the highlights array
 *
 */

function process_highlights($highlights, $return_text) {
    //A modifier that has to go in to account for
    //inserted <span> tags from other highlighting.
    $adjust = 0;
    foreach($highlights as $hItem) {
        $mid_text = substr($return_text, $hItem['start'] + $adjust, $hItem['end'] - $hItem['start']);
        //search first for <p> tags and add a <p><span> tag
        //note that $ps_count is the number of times it was replaced.
        //print "<b>text before:</b> $mid_text <br />";
        $pattern = '/(<p>)/';
        $replacement = '$1<span class="highlight">';
        $matches = array();
        $ps_count = 0;
        $ps_count = preg_match_all($pattern, $mid_text, $matches);
        if($ps_count != 0) {
            $mid_text = preg_replace($pattern, $replacement, $mid_text);
        }
        //print "<b>count:</b>$pscount <br /><b>text after open paragraph tag:</b> $mid_text <br />";

        //now search for </p> and add </span></p> tags
        $pe_count = 0;
        $pattern = '/<\/p>/';
        $replacement = "</span></p>";
        $pe_count = preg_match_all($pattern, $mid_text, $matches);
        if($pe_count != 0) {
            $mid_text = preg_replace($pattern, $replacement, $mid_text);
        }
        //print "<b>text after close paragraph tag:</b> $mid_text <br />";die;

        $return_text = substr($return_text, 0, $hItem['start'] + $adjust) . "<span class=\"highlight\">" .
                $mid_text . "</span>" .
                substr($return_text, $hItem['end'] + $adjust, strlen($return_text) - $hItem['end']);
        $adjust += 31 + (24 * $ps_count) + (7 * $pe_count) ;
    }
    //I need to add a little form on the end for pages that have highlight.
    //This form would contain the id of the php item
    return $return_text;
}


function book_user_inlinefigures($matches) {
    $book_number = $matches[1];
    $chap_number = $matches[2];
    $fig_number = $matches[3];

    //grab the width and heigh if present. The synthax to use here is
    //4-26-1,640,480 the second number is the width, the third is the height
    $pieces = explode(',', rtrim($matches[0], "}"));
    if(count($pieces) > 1) {
        $width = $pieces[1];
        $height = $pieces[2];
    }
    if(!isset($width)) {
        $width = 0;
    }
    if(!isset($height)) {
        $height = 0;
    }

    $figure = pnModFunc('Book', 'user', 'displayfigure',
            array ('fig_number' => $fig_number,
            'chap_number' => $chap_number,
            'book_id' => $book_number,
            'stand_alone' => false,
            'width' => $width,
            'height' => $height));

    return $figure;
}

function book_user_displayfigure($args) {

    $fig_number = FormUtil::getPassedValue('fig_number', isset($args['fig_number']) ? $args['fig_number'] : null);
    $chap_number = FormUtil::getPassedValue('chap_number', isset($args['chap_number']) ? $args['chap_number'] : null);
    $book_id = FormUtil::getPassedValue('book_id', isset($args['book_id']) ? $args['book_id'] : null);
    $stand_alone = FormUtil::getPassedValue('stand_alone', isset($args['stand_alone']) ? $args['stand_alone'] : null);
    $width = FormUtil::getPassedValue('width', isset($args['width']) ? $args['width'] : null);
    $height = FormUtil::getPassedValue('height', isset($args['height']) ? $args['height'] : null);

    if(!isset($stand_alone)) {
        $stand_alone = true;
    }
    if(!isset($width)) {
        $width = 0;
    }
    if(!isset($height)) {
        $height = 0;
    }

    $pnRender = pnRender::getInstance('Book', false);

    //get the chapter title
    $figure = pnModAPIFunc('Book', 'user', 'getfigure', array ('fig_number' => $fig_number, 'chap_number' => $chap_number, 'book_id' => $book_id));
    //permission check
    $book = pnModAPIFunc('Book', 'user', 'get', array ('book_id' => $figure['book_id']));

    if (!SecurityUtil::checkPermission('Book::', "$figure[book_id]::", ACCESS_OVERVIEW)) {
        return LogUtil::registerPermissionError();
    }

    //check to see if we have permission to use the figure
    if($figure['fig_perm'] != 0) {
        $visible_link = book_user_buildlink($figure['img_link'], $figure['fig_title'], $width, $height, true, false, true, $stand_alone);
    } else {
        $visible_link = __("This figure cannot be displayed because permission has not been granted yet.");
    }
    //rint $visible_link;
    if($figure['fig_content']==="") {
        $pnRender->assign('fig_content_empty', "true");
    } else {
        $pnRender->assign('fig_content_empty', "false");
    }

    $pnRender->assign('fig_content', $figure['fig_content']);
    $pnRender->assign('fig_title', $figure['fig_title']);
    $pnRender->assign('img_link', $visible_link);
    $pnRender->assign('fig_number', $fig_number);
    $pnRender->assign('chap_number', $chap_number);
    $pnRender->assign('fig_id', $figure['fig_id']);
    $pnRender->assign('admin_link', $figure['img_link']);

    if (SecurityUtil::checkPermission('Book::', '::', ACCESS_ADMIN)) {
        $pnRender->assign('show_internals', true);
    }
    return $pnRender->fetch('book_user_displayfigure.htm');
}

define ('_MAXPIXELS', '595');

function book_user_buildlink($link, $title = "", $width = 0, $height = 0, $controller = "true", $loop = "false", $autoplay = "true", $stand_alone = true) {
    //if it is a image link, then set it up, else trust that the user
    //has set it up with the right tags.
    $alt_link = preg_replace("|<.*?>|", "", $title);
    if (strstr($link, ".html")) {
        $file_link = fopen($link, "r");
        $ret_link = fread($file_link, filesize($link));
        fclose($file_link);
    } else
    if ((strstr($link, ".gif")) || (strstr($link, ".jpg")) || (strstr($link, ".png"))) {
        $image_data = getimagesize($link);
        if ($width == 0) {
            $width = $image_data[0];
        }
        if ($height == 0) {
            $height = $image_data[1];
        }
        //print $width;die;
        //if the image is too wide, then shrink it to be no larger than max pixels.
        if (!$stand_alone && $width > _MAXPIXELS) {
            $height = $height * _MAXPIXELS/$width;
            $width = _MAXPIXELS;
        }
        $ret_link = "<p class=\"image\"><img class=\"image\" src=\"".$link."\" width=\"".$width."\" height=\"".$height."\" alt=\"".pnVarCensor(DataUtil::formatForDisplayHTML($alt_link))."\" /></p>";
    } else
    if (strstr($link, ".mov")) {
        if (($width == 0) || ($height == 0)) {
            //To determine this, we need this php library
            //do not move it!
            //require_once ('getid3/getid3.php');
            //$getID3 = new getID3;
            //$fileinfo = $getID3->analyze($link);
            $width = 320;
            $height = 336;
        }
        $ret_link = "<p class=\"image\"><object data=\"$link\" width=\"$width\"
				        height=\"$height\">
				        <param name=\"movie\" value=\"$link\" />
				        </object></p>";
    } else
    if (strstr($link, ".swf")) {
        if (($width == 0) || ($height == 0)) {
            $image_data  = getimagesize($link);
            $width = $image_data[0];
            $height = $image_data[1];
        }
           $ret_link =  "<object type=\"application/x-shockwave-flash\" data=\"$link\" width=\"$width\" height=\"$height\">
            <param name=\"movie\" value=\"$link\" /></object>";

        //$ret_link = " <p class=\"image\"><embed src=\"".$link."\" quality=\"high\" bgcolor=\"#FFFFFF\"  width=\"".$width."\" height=\"".$height."\" name=\"animation\" type=\"application/x-shockwave-flash\""." pluginspage=\"http://www.macromedia.com/go/getflashplayer\"></embed></p>";
    } else {
        $ret_link = $link;
    }

    return $ret_link;
}

/**
 * displayglossary
 *
 * Display the entire glossary
 *
 */
function book_user_displayglossary() {
    //you must have permission to read some book.
    if (!SecurityUtil::checkPermission('Book::', "::", ACCESS_OVERVIEW)) {
        return LogUtil::registerPermissionError();
    }
    $pnRender = pnRender::getInstance('Book', false);

    $gloss_data = pnModAPIFunc('Book', 'user', 'getallglossary');
    $pnRender->assign('glossary', $gloss_data);

    return $pnRender->fetch('book_user_displayglossary.htm');
}

/**
 *
 * display book
 *
 * this will render the entire book
 **/
function book_user_displaybook($args) {
    $book_id = FormUtil::getPassedValue('book_id', isset($args['book_id']) ? $args['book_id'] : null);
    extract($args);

    if(!isset($book_id)) {
        return LogUtil::registerArgError();
    }

    // Security check -
    if (!SecurityUtil::checkPermission('Book::', '::', ACCESS_READ)) {
        return LogUtil::registerPermissionError();
    }

    $pnRender = pnRender::getInstance('Book', false);

    $return_text = "";
    //now iterate through each chapter and call display_chapter
    $chapters = pnModAPIFunc('Book', 'user', 'getallchapters', array ('book_id' => $book_id));
    foreach ($chapters as $chap_item) {
        if (SecurityUtil::checkPermission('Book::Chapter', "$book_id::$chap_item[chap_id]", ACCESS_READ)) {
            $ret_text = $ret_text . pnModFunc('Book', 'user', 'displaychapter', array('chap_id' => $chap_item['chap_id']));
        }
    }
    return $ret_text;
}

/**
 * displaychapter
 *
 * Given a chapter id, display all the articles in the chapter
 * in succession. This is useful if one wants to have a printable version
 * There is a link to the printible version in the chapter.
 */

function book_user_displaychapter($args) {

// Get parameters
    $chap_id = FormUtil::getPassedValue('chap_id', isset($args['chap_id']) ? $args['chap_id'] : null);

    $pnRender = pnRender::getInstance('Book', false);
    // Load API.
    
    //grab the chapter data
    $chapter = pnModAPIFunc('Book', 'user', 'getchapter', array ('chap_id' => $chap_id));
    if (!SecurityUtil::checkPermission('Book::Chapter', "$chapter[book_id]::$chapter[chap_id]", ACCESS_READ)) {
        return LogUtil::registerPermissionError();
    }
    //grab all the articles and this time we do need the content
    $articles = pnModAPIFunc('Book', 'user', 'getallarticles', array ('chap_id' => $chap_id));

    $pnRender->assign('chapter_title', $chapter['chap_name']);
    $pnRender->assign('chapter_number', $chapter['chap_number']);

    $article_name = array ();
    $article_content = array ();
    $article_number = array ();

    foreach ($articles as $article_item) {
        if($article_item['art_number'] < 1) {
            continue;
        }
        $article_name[] = $article_item['title'];
        $article_number[] = $article_item['art_number'];
        $article_content[] = $article_item['contents'];
        //we are going to view every article, so we want to increment
        //the counter. This may be too expensive.
        $article_item['counter']++;
        if (!pnModAPIFunc('Book', 'user', 'setcounter', array ('art_id' => $article_item['art_id'], 'counter' => $article_item['counter']))) {
            return LogUtil::registerError(__("Could not set counter."));
        }
    }
    $pnRender->assign('article_content', $article_content);
    $pnRender->assign('article_number', $article_number);
    $pnRender->assign('article_name', $article_name);

    //process all inline figures.
    $return_text = $pnRender->fetch('book_user_displaychapter.htm');
    $return_text = book_user_addfigures($return_text);
    
    
    return $return_text;
}

function book_user_displayarticlesinchapter($args) {
    // Get parameters
    $chap_id = FormUtil::getPassedValue('chap_id', isset($args['chap_id']) ? $args['chap_id'] : null);
    
    // Security check -
    if (!SecurityUtil::checkPermission('Book::', '::', ACCESS_OVERVIEW)) {
        return LogUtil::registerPermissionError();
    }

    $pnRender = pnRender::getInstance('Book', false);

    //grab the chapter data
    $chapter = pnModAPIFunc('Book', 'user', 'getchapter', array ('chap_id' => $chap_id));
    //grab all the articles and this time we do need the content
    $art_array = array ();
    $articles = pnModAPIFunc('Book', 'user', 'getallarticles', array ('chap_id' => $chap_id, 'get_content' => false));

    foreach ($articles as $article_item) {
        if ($article_item['art_number'] > 0) {
            $art_array[] = $article_item;
        }
    }
    if (SecurityUtil::checkPermission('Book::Chapter', '.*::.*', ACCESS_ADMIN)) {
        $pnRender->assign('show_internals', true);
    }

    $pnRender->assign('chapter', $chapter);
    $pnRender->assign('articles', $art_array);
    $pnRender->caching = false;
    if (SecurityUtil::checkPermission('Book::Chapter', "$chapter[book_id]::$chap_id", ACCESS_READ)) {
        return $pnRender->fetch("book_user_toc_row.htm");
    }

    return $pnRender->fetch("book_user_toc_row_overview.htm");
}

/**
 * dodef
 *
 * Given a word or two, check to see if it is in the glossary
 * and if not add it.
 */

function book_user_dodef() {
    $term = FormUtil::getPassedValue('text', isset($args['text']) ? $args['text'] : null);

    //some quick checks
    $pnRender = pnRender::getInstance('Book', false);
    $comment = "";

    if($term == "") {
        $comment = __("No word was selected");
    } else {

        if (str_word_count($term) < 3) {
            if (pnUserLoggedIn()) {
                $URL = pnServerGetVar('HTTP_REFERER');
                $user = pnUserGetVar('uname');
                //check to see that this user had not asked for more than 10 defs

                $items = pnModAPIFunc('Book', 'user', 'getglossary', array ('user' => $user));
                if (count($items) < 11) {
                    //check to see if it is already defined.
                    $ispresent = pnModAPIFunc('Book', 'user', 'findglossaryterm', array ('term' => $term));
                    if (!$ispresent) {
                        // The API function is called.
                        $gloss_id = pnModAPIFunc('Book', 'admin', 'createglossary', array ('term' => $term, 'definition' => "", 'URL' => $URL, 'user' => $user));

                        if ($gloss_id != false) {
                            // Success
                            $comment = __('Thank you for submitting this word. The authors will define it soon.');
                        }
                    } else {
                        //if the book term is defined then redirect to that term.
                        //make all lowercase before making the url
                        $term =  strtolower($term);
                        $url = pnModURL('Book', 'user', 'displayglossary') . "#$term";
                        pnRedirect($url);
                    }
                } else {
                    $comment = __('You can only submit 10 words per user.');
                }
            } else {
                $comment = __('You need to be logged in to suggest words to define.');
            }
        } else {
            $comment = __('Phrases to define can be no longer that 3 words.');
        }
    }
    //make sure that a glassary term is not already defined.
    $pnRender->assign('comment', $comment);
    return $pnRender->fetch('book_user_glossaddcomment.htm');
}

/**
 * collecthighlights
 *
 * Take all the highlights that a user has highlight for the book
 * and then display them to the user. This should be a useful study tool
 *
 */
function book_user_collecthighlights() {
    //Find the current user ID
    $uid = pnUserGetVar('uid');
    $chap_ids = FormUtil::getPassedValue('chap_ids', isset($args['chap_ids']) ? $args['chap_ids'] : null);

    $do_chaps = isset($chap_ids);
    //Check to make sure it is valid
    if($uid == "") {
        //user id is empty, we are not in
        return LogUtil::registerError(__('You are not logged in. In this case you cannot add highlights.'));
    }

    //get all the highligts for this user
    $highlights = pnModAPIFunc('Book',
            'user',
            'gethighlights', array ('uid' => $uid));


    //collect all the centents from the articles
    //walk through each highlight and get the important information
    $highlight_text = array();
    $article_title = array();
    $article_chapter = array();
    $article_section = array();
    $art_ids = array();

    foreach($highlights as $hItem) {
        //grab each article
        $article = pnModAPIFunc('Book', 'user', 'getarticle', array ('art_id' => $hItem['art_id']));

        //now check for authorization, if not just continue. Frankly there should be none of these
        if (!SecurityUtil::checkPermission("Book::Chapter", "$article[book_id]::$article[chap_id]", ACCESS_READ)) {
            continue;
        }

        //if we have the chapter array, then check to see
        //if we want to grab this chapter
        $chapter = pnModAPIFunc('Book', 'user', 'getchapter', array ('chap_id' => $article[chap_id]));
        if($do_chaps) {
            if(!in_array($chapter['chap_number'], $chap_ids)) {
                continue;
            }
        }

        $article_chapter[] = $chapter['chap_number'];
        //grab that portion of the article that is highlighted.
        $highlight_text[] = substr($article['contents'], $hItem['start'], $hItem['end'] - $hItem['start']);
        $article_title[] = $article['title'];
        $article_section[] = $article['art_number'];
        $art_ids[] = $article['art_id'];

    }

    $pnRender = pnRender::getInstance('Book', false);
    $pnRender->assign('art_ids', $art_ids);
    $pnRender->assign('content', $highlight_text);
    $pnRender->assign('title', $article_title);
    $pnRender->assign('section', $article_section);
    $pnRender->assign('chapter', $article_chapter);


    return $pnRender->fetch('book_user_collecthighlights.htm');
}

/**
 * dohighlight
 *
 * The user has presumably selected some text. Change the highlight on it
 * so that it is yellow.
 */
function book_user_dohighlight() {
    $inText = FormUtil::getPassedValue('text', isset($args['text']) ? $args['text'] : null);
    $art_id = FormUtil::getPassedValue('art_id', isset($args['art_id']) ? $args['art_id'] : null);

    //grab the user
    if($inText == "") {
        return LogUtil::registerError(__('You can only highligh text in articles'));
    }
    //Get the referring url
    $url = pnServerGetVar('HTTP_REFERER');
    if($art_id < 0) {
        return LogUtil::registerError(__('You can only highligh text in articles'));
    }


    //grab the article to find the offsets
    $art_array = pnModAPIFunc('Book', 'user', 'getarticle', array ('art_id' => $art_id));
    //before doing anything else, make sure they are authorized to highlight.

    if (!SecurityUtil::checkPermission('Book::Chapter', "$art_array[book_id]::$art_array[chap_id]", ACCESS_READ)) {
        return LogUtil::registerPermissionError();
    }
    $content = $art_array['contents'];

    $uid = pnUserGetVar('uid');
    if($uid == "") {
        //user id is empty, we are not in
        return LogUtil::registerError(__('You are not logged in. In this case you cannot add highlights.'));
    }

    //find the offsets
    //first extract the first three words and last three words of the
    //incoming text
    //get rid of any newlines in the content and in the in text.
    $content = preg_replace('/[\n|\r]/', ' ', $content);
    $inText = preg_replace('/[\n|\r]/', ' ', $inText);

    $string_words = explode(" ", $inText, 500);
    //check to make sure the words are less than 500
    $words = count($string_words);
    if($words > 499) {
        return LogUtil::registerError(__('The amount of text your are trying to highlight is too long'));

    }
    //print $words;die;
    if($words < 4) {
        return LogUtil::registerError(__('You must highlight at least four words.'));
    }
    //get rid of any newlines in the content and in the in text.
    $size = strlen($content);
    //print "original : $size\n <pre>$content</pre> <br />";
    //This function removes all html code and replaces it with spaces.
    $pattern = "|<[^>]+>|U";
    $content = preg_replace_callback($pattern, "sub_html", $content);
    $size = strlen($content);
    //print "substitute $size: \n <pre>$content</pre> <br />";
    //create the pattern of the first three words.Note that the wildcard allow html to be in between.
    $inter_char = "[\s|\.|\?|\!]*?";
    $pattern = '/\s*?'. addcslashes($string_words[0], "()") . $inter_char. addcslashes($string_words[1], "()") . $inter_char. addcslashes($string_words[2], "()") . $inter_char. addcslashes($string_words[3], "()") . '/';
    //print "Content: <br />$content<br />";
    //print $pattern; die;

    $matches = array();
    preg_match($pattern, $content, $matches, PREG_OFFSET_CAPTURE);
    $start = $matches[0][1];
    //now grab the ending text
    $pattern = '/' . $inter_char . addcslashes($string_words[$words - 4], "()") . $inter_char. addcslashes($string_words[$words - 3], "()") . $inter_char. addcslashes($string_words[$words - 2], "()") . $inter_char. addcslashes($string_words[$words - 1], "()") . '/';
    preg_match($pattern, $content, $matches, PREG_OFFSET_CAPTURE);
    //you want the end of the match, preg_match send back the start of the match.
    $end = $matches[0][1] + strlen($matches[0][0]);
    if($end == 0 || ($start > $end)) {
        //print "Start: $start, End: $end <br />";
        return LogUtil::registerError(__('You cannot highligh that text. Try a slightly different selection.') . "start:$start end:$end");
    }

    //if there is a big gap between highlights, it may mean that
    //we have an early match. try again to find a match later in the text..
    if($end - $start > 3000) {
        $pattern = '/' . $inter_char . addslashes($string_words[0]) . $inter_char. addslashes($string_words[1]) . $inter_char. addslashes($string_words[2]) . $inter_char. addslashes($string_words[3]) . '/s';
        $matches = array();
        preg_match_all($pattern, $content, $matches, PREG_OFFSET_CAPTURE);
        $new_start = $matches[0][1][1];
        if($new_start != 0) {
            $start = $new_start;
        }
    }

    //finally make sure that this area is not already highlighted.
    //if it is, unhighlight the area.
    $currentHighLights = pnModAPIFunc('book',
            'user',
            'gethighlights',
            array('uid' => $uid,
            'art_id' => $art_id));

    $recordHighlight = true;
    if($currentHighLights) {
        //cycle through each highlight and see if we
        //already have it highlighted. If so, remove the highlight
        foreach($currentHighLights as $hItem) {
            if( ($start >= $hItem['start']) && ($start < $hItem['end'])) {
                $recordHighlight = false;
                //now put in a call to delete the highlight
                $success = pnModAPIFunc('book',
                        'admin',
                        'deletehighlight',
                        array('id' =>$hItem['id']));
                if(!$success) {
                    return DataUtil::formatForDisplayHTML("I was unable to delete that highlight");
                } else {
                    //if we deleted a highlight, then we are done.
                    pnRedirect($url);
                    return true;
                }
            }
        }
    }
    if(!$recordHighlight) {
        pnRedirect($url);
        return true;
    }

    //record this in the database;
    if(!pnModAPIFunc('Book',
    'admin',
    'createhighlight',
    array('uid' => $uid,
    'art_id' => $art_id,
    'start' => $start,
    'end' => $end))) {
        //set an error message and return false
        SessionUtil::setVar('error_msg', __('Highlighting failed.') . "dohighlight");
        return false;

    }
    //finally redirect to the page again, this time with highlights
    pnRedirect($url);
    return true;
}
function sub_html($matches) {
    //figure out the size of the match
    $count = strlen($matches[0]);
    $ret_text = "";
    //now create a string with that many spaces
    for($i=0; $i<$count;$i++) {
        $ret_text .= " ";
    }
    return $ret_text;
}

/**
 * checkuserstatus
 *
 * A security function to ensure that no more than one or two sessions
 * are logged in using the same user id. If they are, two people are trying to
 * use the same account for access to the book.
 *
 * This funciton does make assumptions about the sessions table, but hopefully they
 * will hold for version 0.8. Right now, it looks like it will hold true
 */
function book_user_checkuserstatus() {

    if(!pnModGetVar('Book', 'securebooks')) {
        return;
    }

    if(pnUserLoggedIn()) {
        $uid = pnUserGetVar('uid');
        $dbconn =& pnDBGetConn(true);
        $pntable =& pnDBGetTables();
        $ipaddr = SessionUtil::getVar('ipaddr');
        
        $sessioninfocolumn = &$pntable['session_info_column'];
        $sessioninfotable = $pntable['session_info'];
        //use the time limit we use for killing a session.
        //This seems like a good number. After 10 min. they are
        //considered no readying anymore. Also, if two people
        //are trying to use the book with the same user name
        //them will get locked out for 10 min.
        $timelimit = (time() - (int)(pnConfigGetVar('secinactivemins') * 60));
        $where = "WHERE " . $sessioninfocolumn['uid'] . " = " . $uid . " AND " . $sessioninfocolumn['lastused'] . " > " . $timelimit;
        $result = DBUtil::selectObjectArray('session_info', $where);
        //only continue if there is no error
        $firstIp = false;
        if ($result !== false) {
            foreach ($result as $sesItem) {
                // Obtain the ipaddr of the sessions that are active
                if($firstIp == false) {
                    $firstIp = $sesItem['ipaddr'];
                    continue;
                }
                //make sure they are all coming from the same computer,
                //if not, log the user out.
                if($firstIp != $sesItem['ipaddr']) {
                    $url = pnModURL('book', 'user', 'morethanoneuser');
                    pnRedirect($url);
                    break;
                }
            }
        }
    }
}

/**
 * morethanoneuser
 *
 * The user is cheating and more than one person are using the web site at the same time.
 * Send an explanation that this is the problem and then log them out.
 */

function book_user_morethanoneuser() {
    $pnRender = pnRender::getInstance('Book', false);

    pnUserLogOut();
    return $pnRender->fetch('book_user_morethanoneuser.htm');
}
?>