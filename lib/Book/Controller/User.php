<?php

// pnuser.php,v 1.18 2007/03/16 01:58:56 paustian Exp
// ----------------------------------------------------------------------
// PostNuke Content Management System
// Copyright (C) 2002 by the PostNuke Development Team.
// http://www.postnuke.com/
// ----------------------------------------------------------------------
// Based on:
// PHP-NUKE Web Portal System - http://phpnuke.org/
// Thatware - http://thatware.org/
// ----------------------------------------------------------------------
// LICENSE
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License (GPL)
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// To read the license please visit http://www.gnu.org/copyleft/gpl.html
// ----------------------------------------------------------------------
// Original Author of file: Timothy Paustian
// Purpose of file:  Book user display functions
// ----------------------------------------------------------------------
class Book_Controller_User extends Zikula_AbstractController {
    private $maxpixels = 595;
    /**
     * the main user function
     * This function is the default function, and is called whenever the module is
     * initiated without defining arguments.  As such it can be used for a number
     * of things, but most commonly it either just shows the module menu and
     * returns or calls whatever the module designer feels should be the default
     * function (often this is the view() function)
     */
    public function main() {
        // Create output object - this object will store all of our output so that
        // we can return it easily when required
        $render = Zikula_View::getInstance('Book', false);

        // Security check
        if (!SecurityUtil::checkPermission('Book::', '::', ACCESS_READ)) {
            return LogUtil::registerPermissionError();
        }

        // For this function we want the user to see the books that are available for display
        //Initially I am going to make this just list the books.
        //I will get fancier as time goes on, adding cover art and such.
        //A list of books
        $bookItems = ModUtil::apiFunc('Book', 'user', 'getall', array('startnum' => 1));

        if ($bookItems == 0) {
            //if we dont' have a book, then you
            //cannot have chapters
            return LogUtil::registerError(__('There are no books to display'));
        }
        //I now need to convert this to a new array
        $bookTitleArray = array();
        foreach ($bookItems as $item) {

            if (SecurityUtil::checkPermission('Book::', "$item[bid]::.*", ACCESS_READ)) {
                $bookTitleArray[] = array('url' => pnModurl('Book', 'user', 'toc', array('bid' => $item['bid'])), 'title' => $item['name']);
            } else {
                $bookTitleArray[] = array('title' => $item['title']);
            }
        }

        // Return the output that has been generated by this function
        $render->assign('names', $bookTitleArray);

        return $render->fetch('book_user_main.htm');
    }

    public function toc($args) {
        // Get parameters from whatever input we need.
        $bid = FormUtil::getPassedValue('bid', isset($args['bid']) ? $args['bid'] : null);

        // if this get called without a
        if (!isset($bid)) {
            $bid = 4;
        }
        if (!is_numeric($bid)) {
            return LogUtil::registerArgsError();
            ;
        }

        $book = ModUtil::apiFunc('Book', 'user', 'get', array('bid' => $bid));

        //Make sure the book exists
        if (!$book) {
            return LogUtil::registerError(__('That book does not exist.'));
        }
        // The API function is called.  The arguments to the function are passed in
        // as their own arguments array
        $chapters = ModUtil::apiFunc('Book', 'user', 'getallchapters', array('bid' => $bid));

        // The return value of the function is checked here, and if the function
        // suceeded then an appropriate message is posted.
        if (!$chapters) {
            return LogUtil::registerError(__('No chapters are present'));
        }

        // Create output object
        $render = Zikula_View::getInstance('Book', false);

        // Loop through each chapter and extract the text we need for display.
        //$toc_string = "<ol>\n";
        $chapter_data = array();
        if (SecurityUtil::checkPermission('Book::Chapter', "$book[bid]::.*", ACCESS_ADMIN)) {
            $render->assign('show_internals', true);
        }

        foreach ($chapters as $chapter_item) {
            $cid = $chapter_item['cid'];
            if ($chapter_item['number'] > 0) {
                $articles = ModUtil::apiFunc('Book', 'user', 'getallarticles', array('cid' => $cid, 'get_content' => false));
                $art_array = array();
                foreach ($articles as $article_item) {
                    if ($article_item['aid'] > 0) {
                        $art_array[] = $article_item;
                    }
                }

                $render->assign('chapter', $chapter_item);
                //$render->assign('articles', $art_array);
                $render->caching = false;
                if (SecurityUtil::checkPermission('Book::Chapter', "$book[bid]::$chapter_item[cid]", ACCESS_READ)) {
                    $chapter_data[] = $render->fetch("book_user_toc_row.htm");
                } else {
                    $chapter_data[] = $render->fetch("book_user_toc_row_overview.htm");
                }
                $render->caching = true;
            }
        }

        // The chapters that are displayed on this overview page depend on the individual
        // user permissions. Therefor, we can not cache the whole page.
        // The single entries are cached, though.
        $render->caching = false;

        // Display the entries
        $render->assign('chapters', $chapter_data);
        $render->assign('book', $book);

        return $render->fetch('book_user_toc.htm');
    }

    public function shorttoc($args) {
        // Get parameters from whatever input we need.
        $bid = FormUtil::getPassedValue('bid', isset($args['bid']) ? $args['bid'] : null);
        $aid = FormUtil::getPassedValue('aid', isset($args['aid']) ? $args['aid'] : null);
        // if this get called without a
        if (!isset($bid)) {
            if (($args['bid'] != "")) {
                $bid = $args['bid'];
            } else {
                return "";
            }
        }

        if (!is_numeric($bid)) {
            return LogUtil::registerArgsError();
            ;
        }

        // The API function is called.  The arguments to the function are passed in
        // as their own arguments array
        $chapters = ModUtil::apiFunc('Book', 'user', 'getallchapters', array('bid' => $bid));

        // The return value of the function is checked here, and if the function
        // suceeded then an appropriate message is posted.
        if (!$chapters) {
            return LogUtil::registerError(__('There are no chapters.'));
        }

        // Create output object
        $render = Zikula_View::getInstance('Book', false);

        // Loop through each chapter and extract the text we need for display.
        //$toc_string = "<ol>\n";
        $chapter_data = array();
        if (SecurityUtil::checkPermission('Book::Chapter', '.*::.*', ACCESS_ADMIN)) {
            $render->assign('show_internals', true);
        }

        foreach ($chapters as $chapter_item) {
            $cid = $chapter_item['cid'];
            if ($chapter_item['number'] > 0) {
                if (SecurityUtil::checkPermission('Book::Chapter', "$bid::$chapter_item[cid]", ACCESS_OVERVIEW)) {
                    $chapter_item['name'] = $this->myTruncate2($chapter_item['name'], 25);
                    $chapter_data[] = $chapter_item;
                }
            }
        }
        //grab the username and place it in the code
        $user_name = UserUtil::getVar('uname');

        if ($user_name !== '') {
            $render->assign('loggedIn', "doIT");
        }
        $render->assign('chapters', $chapter_data);
        $render->assign('aid', $aid);

        $render->caching = false;
        $text = $render->fetch('book_user_shorttoc.htm');
        
        return $text;
    }

// Original PHP code by Chirp Internet: www.chirp.com.au
// Please acknowledge use of this code by including this header.

    function myTruncate2($string, $limit, $break = " ", $pad = "...") {
        // return with no change if string is shorter than $limit
        if (strlen($string) <= $limit)
            return $string;

        $string = substr($string, 0, $limit);
        if (false !== ($breakpoint = strrpos($string, $break))) {
            $string = substr($string, 0, $breakpoint);
        }

        return $string . $pad;
    }

    /**
     * view items
     * This is a standard function to provide an overview of all of the items
     * available from the module.
     */
    public function view($args) {
        // Get parameters from whatever input we need.
        $bid = FormUtil::getPassedValue('bid', isset($args['bid']) ? $args['bid'] : null);

        // if this get called without a
        if (!isset($bid)) {
            $bid = 1;
        }
        if (!is_numeric($bid)) {
            return LogUtil::registerArgsError();
            ;
        }

        $book = ModUtil::apiFunc('Book', 'user', 'get', array('bid' => $bid));

        //Make sure the book exists
        if (!$book) {
            return LogUtil::registerError(__('That book does not exist.'));
        }
        // The API function is called.  The arguments to the function are passed in
        // as their own arguments array
        $chapters = ModUtil::apiFunc('Book', 'user', 'getallchapters', array('bid' => $bid));

        // The return value of the function is checked here, and if the function
        // suceeded then an appropriate message is posted.
        if (!$chapters) {
            return LogUtil::registerError(__('There are no chapters for this book.'));
        }

        // Create output object
        $render = Zikula_View::getInstance('Book', false);

        // Loop through each chapter and extract the text we need for display.
        $chapter_titles = array();
        $chapter_ids = array();
        $number = array();
        //right now this is not working with the permission I need to test
        foreach ($chapters as $chapter_item) {
            if (SecurityUtil::checkPermission('Book::Chapter', "$book[bid]::$chapter_item[cid]", ACCESS_OVERVIEW)) {

                $chapter_titles[] = $chapter_item['name'];
                $chapter_ids[] = $chapter_item['cid'];
                $number[] = $chapter_item['number'];
            }
        }

        // The chapters that are displayed on this overview page depend on the individual
        // user permissions. Therefor, we can not cache the whole page.
        // The single entries are cached, though.
        $render->caching = false;

        // Display the entries
        $render->assign('titles', $chapter_titles);
        $render->assign('ids', $chapter_ids);
        $render->assign('number', $number);
        $render->assign('book', $book['name']);

        return $render->fetch('book_user_view.htm');
    }

    /**
     * display item
     * This is a standard function. We use it to provide all the chatpers in a book and links
     * to the articles within that chapter
     * available from the module.
     */
    public function display($args) {
        // Security check -
        if (!SecurityUtil::checkPermission('Book::', '::', ACCESS_OVERVIEW)) {
            return LogUtil::registerPermissionError();
        }
        // Get parameters
        $cid = FormUtil::getPassedValue('cid', isset($args['cid']) ? $args['cid'] : null);
        // User functions of this type can be called by other modules.
        extract($args);

        if (!is_numeric($cid)) {
            return LogUtil::registerArgsError();
            ;
        }

        // Create output object
        $render = Zikula_View::getInstance('Book', false);
        // The item ID is appropriate to be used as the cache ID.
        $render->cache_id = $cid;

        //get the chapter title
        $chapter = ModUtil::apiFunc('Book', 'user', 'getchapter', array('cid' => $cid));
        if (!$chapter) {
            return LogUtil::registerError(__('There are no chapters.'));
        }
        $render->assign('chapter', $chapter['name']);
        //Get the article data. We do not need the content information
        //so send that along.

        $articles = ModUtil::apiFunc('Book', 'user', 'getallarticles', array('cid' => $cid, 'get_content' => false));

        //Did we get the chatpers data?
        if (!$articles) {
            return LogUtil::registerError(__('There are no articles.'));
        }
        //extract the articles to display.
        $art_titles = array();
        $aids = array();
        $section_num = array();
        $i = 1;
        foreach ($articles as $article_item) {
            $art_titles[] = $article_item['title'];
            $aids[] = $article_item['aid'];
            $section_num[] = "$chapter[number]" . "-" . $i;
            $i++;
        }

        $render->assign('titles', $art_titles);
        $render->assign('ids', $aids);
        $render->assign('section_number', $section_num);
        if (SecurityUtil::checkPermission('Book::Chapter', "$bid::$chapter[cid]", ACCESS_READ)) {
            //produce links to articles for those that can read
            $render_output = $render->fetch('book_user_display.htm');
        } else {
            //only allow access to the titles of the articles
            //and not links to them
            $render_output = $render->fetch('book_user_displayoverview.htm');
        }

        // Return the output that has been generated by this function
        return $render_output;
    }

    /**
     * Display an article
     *
     */
    public function displayarticle($args) {
        // Get parameters
        $aid = FormUtil::getPassedValue('aid', isset($args['aid']) ? $args['aid'] : null);
        $do_glossary = FormUtil::getPassedValue('do_glossary', isset($args['do_glossary']) ? $args['do_glossary'] : null);

        if (!isset($do_glossary)) {
            $do_glossary = true;
        }
        pnModFunc('book', 'user', 'checkuserstatus');

        $render = Zikula_View::getInstance('Book', false);

        //get the chapter title
        $article = ModUtil::apiFunc('Book', 'user', 'getarticle', array('aid' => $aid));
        $chapter = ModUtil::apiFunc('Book', 'user', 'getchapter', array('cid' => $article['cid']));

        // Security check -
        if (!SecurityUtil::checkPermission('Book::Chapter', "$article[bid]::$article[cid]", ACCESS_READ)) {
            return LogUtil::registerPermissionError();
        }
        $content = $article['contents'];
        //Now add the highlights if necessary
        $uid = UserUtil::getVar('uid');
        if ($uid != "") {
            $highlights = ModUtil::apiFunc('Book', 'user', 'gethighlights', array('uid' => $uid, 'aid' => $aid));
            if ($highlights) {
                $content = $this->process_highlights($highlights, $content);
            }
        }
        if ($article['next'] == 0) {
            //no link assigned, lets see if we can find the next one
            $next_art = ModUtil::apiFunc('Book', 'user', 'getarticlebyartnumber', array('number' => $article['number'] + 1, 'cid' => $article['cid']));
            $article['next'] = $next_art['aid'];
        }
        if (($article['prev'] == 0) || ($article['number'] != 1)) {
            //no link assigned, lets see if we can find the next one
            $prev_art = ModUtil::apiFunc('Book', 'user', 'getarticlebyartnumber', array('number' => $article['number'] - 1, 'cid' => $article['cid']));
            $article['prev'] = $prev_art['aid'];
        }
        $render->assign('aid', $article['aid']);
        $render->assign('cid', $article['cid']);
        $render->assign('art_number', $article['number']);
        $render->assign('number', $chapter['number']);
        $render->assign('content', $content);
        $render->assign('counter', $article['counter']);
        $render->assign('title', $article['title']);
        $render->assign('next', $article['next']);
        $render->assign('prev', $article['prev']);
        $render->assign('bid', $article['bid']);
        //this code is used for the hook
        $return_url = new Zikula_ModUrl('Book', 'User', 'displayarticle', '', array(aid => $aid));
        $render->assign('returnurl', $return_url);

        //call the user api to increment the counter
        if (!ModUtil::apiFunc('Book', 'user', 'setcounter', array('aid' => $aid, 'counter' => $article['counter']))) {
            return LogUtil::registerError(__('Count not set book counter.'));
        }
        if (SecurityUtil::checkPermission('Book::Chapter', "$article[bid]::$article[cid]", ACCESS_EDIT)) {
            $render->assign('show_internals', true);
        }

        $return_text = $render->fetch('book_user_displayarticle.htm');

        $return_text = $this->addfigures($return_text);
        
        //work in the glossary items
        if ($do_glossary) {
            $return_text = $this->add_glossary_defs(array('in_text' => $return_text));
        }

        return $return_text;
    }

//book_user_addfigures
//I factored this out of the above so that I could call it from the admin
//code for exporting the chapters.
    public function addfigures($ioText) {
        //substitute all the figures
        $pattern = "|<!--\(Figure ([0-9]{1,2})-([0-9]{1,3})-([0-9]{1,3})\)-->|";
        $ioText = preg_replace_callback($pattern, "Book_Controller_User::inlinefigures", $ioText);
        //this is a legacy pattern
        $pattern = "|{Figure ([0-9]{1,2})-([0-9]{1,3})-([0-9]{1,3}).*}|";
        $ioText = preg_replace_callback($pattern, "Book_Controller_User::inlinefigures", $ioText);
        return $ioText;
    }

    /**
     * book_add_glossary_defs
     *
     * Given some text, insert the glossary definitions.
     *
     * @param inText - the text to add glossary definitions to
     * @return retText - the text with glossary definitions addeed
     *
     */
    public function add_glossary_defs($args) {
        $in_text = $args['in_text'];
        // Security check - important to do this as early on as possible to
        // avoid potential security holes or just too much wasted processing
        if (!SecurityUtil::checkPermission('Book::', "::", ACCESS_READ)) {
            LogUtil::registerPermissionError();
            return false;
        }

        //all the work is done in this funcion
        $pattern = "|<a class=\"glossary\">(.*?)</a>|";
        $ret_text = preg_replace_callback($pattern, array($this, 'glossary_add'), $in_text);

        return $ret_text;
    }

    /**
     *  glossary_add
     * This is a callback function to convert glossary terms into their definitions.
     * I am added it here and not into the text to keep from polluting the text 
     * with glossary definitions.
     * 
     * @param $matches
     * @return the match text to insert 
     */
    public function glossary_add($matches) {
        $term = $matches[1];
        $item = array();
        $where = "a.term=' " . DataUtil::formatForStore($term) . "'";
        
        $item = $this->entityManager->getRepository('Book_Entity_BookGloss')->getGloss('', $where);
        
        if ($item === false) {
            //This did not work, try searching for match instead
            $where = "a.term LIKE '" . DataUtil::formatForStore($term) . "%'";
            $item = $this->entityManager->getRepository('Book_Entity_BookGloss')->getGloss('', $where);
        }
        // Check for an error and if so
        //just return. This is not an error, we just won't replace it
        //$matches[0] contains the found string, so we just return the found
        //string.
        if ($item === false) {
            return $matches[0];
        }
        $definition = $item['definition'];
        $lcterm = strtolower($term);
        $url = DataUtil::formatForDisplayHTML(pnModurl('Book', 'user', 'displayglossary')) . "#$lcterm";
        $ret_text = "<a class=\"glossary\" href=\"$url\" onmouseover=\"tooltip.pop(this, '$definition') \">$term</a>";
        return $ret_text;
    }

    /**
     * process_highlights
     *
     * Add highlight to the incomping text, based upon the offsets in the highlights array
     *
     */
    function process_highlights($highlights, $return_text) {
        //A modifier that has to go in to account for
        //inserted <span> tags from other highlighting.
        $adjust = 0;
        foreach ($highlights as $hItem) {
            $mid_text = substr($return_text, $hItem['start'] + $adjust, $hItem['end'] - $hItem['start']);
            //search first for <p> tags and add a <p><span> tag
            //note that $ps_count is the number of times it was replaced.
            //print "<b>text before:</b> $mid_text <br />";
            $pattern = '/(<p>)/';
            $replacement = '$1<span class="highlight">';
            $matches = array();
            $ps_count = 0;
            $ps_count = preg_match_all($pattern, $mid_text, $matches);
            if ($ps_count != 0) {
                $mid_text = preg_replace($pattern, $replacement, $mid_text);
            }
            //print "<b>count:</b>$pscount <br /><b>text after open paragraph tag:</b> $mid_text <br />";
            //now search for </p> and add </span></p> tags
            $pe_count = 0;
            $pattern = '/<\/p>/';
            $replacement = "</span></p>";
            $pe_count = preg_match_all($pattern, $mid_text, $matches);
            if ($pe_count != 0) {
                $mid_text = preg_replace($pattern, $replacement, $mid_text);
            }
            //print "<b>text after close paragraph tag:</b> $mid_text <br />";die;

            $return_text = substr($return_text, 0, $hItem['start'] + $adjust) . "<span class=\"highlight\">" .
                    $mid_text . "</span>" .
                    substr($return_text, $hItem['end'] + $adjust, strlen($return_text) - $hItem['end']);
            $adjust += 31 + (24 * $ps_count) + (7 * $pe_count);
        }
        //I need to add a little form on the end for pages that have highlight.
        //This form would contain the id of the php item
        return $return_text;
    }

    static public function inlinefigures($matches) {
        $book_number = $matches[1];
        $chap_number = $matches[2];
        $fig_number = $matches[3];

        //grab the width and heigh if present. The synthax to use here is
        //4-26-1,640,480 the second number is the width, the third is the height
        $pieces = explode(',', rtrim($matches[0], "}"));
        if (count($pieces) > 1) {
            $width = $pieces[1];
            $height = $pieces[2];
        }
        if (!isset($width)) {
            $width = 0;
        }
        if (!isset($height)) {
            $height = 0;
        }

        $figure = pnModFunc('Book', 'user', 'displayfigure', array('fig_number' => $fig_number,
            'chap_number' => $chap_number,
            'bid' => $book_number,
            'stand_alone' => false,
            'width' => $width,
            'height' => $height));

        return $figure;
    }

    public function displayfigure($args) {

        $fig_number = FormUtil::getPassedValue('fig_number', isset($args['fig_number']) ? $args['fig_number'] : null);
        $chap_number = FormUtil::getPassedValue('chap_number', isset($args['chap_number']) ? $args['chap_number'] : null);
        $bid = FormUtil::getPassedValue('bid', isset($args['bid']) ? $args['bid'] : null);
        $stand_alone = FormUtil::getPassedValue('stand_alone', isset($args['stand_alone']) ? $args['stand_alone'] : null);
        $width = FormUtil::getPassedValue('width', isset($args['width']) ? $args['width'] : null);
        $height = FormUtil::getPassedValue('height', isset($args['height']) ? $args['height'] : null);

        if (!isset($stand_alone)) {
            $stand_alone = true;
        }
        if (!isset($width)) {
            $width = 0;
        }
        if (!isset($height)) {
            $height = 0;
        }

        $render = Zikula_View::getInstance('Book', false);

        //get the chapter title
        $figure = ModUtil::apiFunc('Book', 'user', 'getfigure', array('fig_number' => $fig_number, 
            'chap_number' => $chap_number, 
            'bid' => $bid));
        //permission check
        //$book = ModUtil::apiFunc('Book', 'user', 'get', array('bid' => $figure['bid']));

        if (!SecurityUtil::checkPermission('Book::', "$figure[bid]::", ACCESS_OVERVIEW)) {
            return LogUtil::registerPermissionError();
        }

        //check to see if we have permission to use the figure
        if ($figure['perm'] != 0) {
            $visible_link = $this->buildlink($figure['img_link'], $figure['title'], $width, $height, true, false, true, $stand_alone);
        } else {
            $visible_link = __("This figure cannot be displayed because permission has not been granted yet.");
        }
        //rint $visible_link;
        if ($figure['content'] === "") {
            $render->assign('content_empty', "true");
        } else {
            $render->assign('content_empty', "false");
        }
       
        $render->assign('content', $figure['content']);
        $render->assign('title', $figure['title']);
        $render->assign('img_link', $visible_link);
        $render->assign('fig_number', $fig_number);
        $render->assign('chap_number', $chap_number);
        $render->assign('fid', $figure['fid']);
        $render->assign('admin_link', $figure['img_link']);

        if (SecurityUtil::checkPermission('Book::', '::', ACCESS_ADMIN)) {
            $render->assign('show_internals', true);
        }
        return $render->fetch('book_user_displayfigure.htm');
    }

    public function buildlink($link, $title = "", $width = 0, $height = 0, $controller = "true", $loop = "false", $autoplay = "true", $stand_alone = true) {
        //if it is a image link, then set it up, else trust that the user
        //has set it up with the right tags.
        $alt_link = preg_replace("|<.*?>|", "", $title);
        $ret_link = "nothing";
        
        if (strstr($link, ".html")) {
            $file_link = fopen($link, "r");
            $ret_link = fread($file_link, filesize($link));
            fclose($file_link);
        } else
        if ((strstr($link, ".gif")) || (strstr($link, ".jpg")) || (strstr($link, ".png"))) {
            $image_data = getimagesize($link);
            if ($width == 0) {
                $width = $image_data[0];
            }
            if ($height == 0) {
                $height = $image_data[1];
            }
            //print $width;die;
            //if the image is too wide, then shrink it to be no larger than max pixels.
            if (!$stand_alone && $width > $this->maxpixels) {
                $height = $height * $this->maxpixels / $width;
                $width = $this->maxpixels;
            }
            
            $ret_link =  "<p class=\"image\"><img class=\"image\" src=\"" . $link . "\" width=\"" . $width . "\" height=\"" . $height . "\" /></p>";
            
        } else
        if (strstr($link, ".mov")) {
            if (($width == 0) || ($height == 0)) {
                //To determine this, we need this php library
                //do not move it!
                //require_once ('getid3/getid3.php');
                //$getID3 = new getID3;
                //$fileinfo = $getID3->analyze($link);
                $width = 320;
                $height = 336;
            }
            $ret_link = "<p class=\"image\"><object data=\"$link\" width=\"$width\"
				        height=\"$height\">
				        <param name=\"movie\" value=\"$link\" />
				        </object></p>";
        } else
        if (strstr($link, ".swf")) {
            if (($width == 0) || ($height == 0)) {
                $image_data = getimagesize($link);
                $width = $image_data[0];
                $height = $image_data[1];
            }
            $ret_link = "<object type=\"application/x-shockwave-flash\" data=\"$link\" width=\"$width\" height=\"$height\">
            <param name=\"movie\" value=\"$link\" /></object>";

            //$ret_link = " <p class=\"image\"><embed src=\"".$link."\" quality=\"high\" bgcolor=\"#FFFFFF\"  width=\"".$width."\" height=\"".$height."\" name=\"animation\" type=\"application/x-shockwave-flash\""." pluginspage=\"http://www.macromedia.com/go/getflashplayer\"></embed></p>";
        } else {
            $ret_link = $link;
        }
        return $ret_link;
    }

    /**
     * displayglossary
     *
     * Display the entire glossary
     *
     */
    public function displayglossary() {
//you must have permission to read some book.
        if (!SecurityUtil::checkPermission('Book::', "::", ACCESS_OVERVIEW)) {
            return LogUtil::registerPermissionError();
        }
        $render = Zikula_View::getInstance('Book', false);

        $gloss_data = ModUtil::apiFunc('Book', 'user', 'getallglossary');
        $render->assign('glossary', $gloss_data);

        return $render->fetch('book_user_displayglossary.htm');
    }

    /**
     *
     * display book
     *
     * this will render the entire book
     * */
    public function displaybook($args) {
        $bid = FormUtil::getPassedValue('bid', isset($args['bid']) ? $args['bid'] : null);
        extract($args);

        if (!isset($bid)) {
            return LogUtil::registerArgError();
        }

// Security check -
        if (!SecurityUtil::checkPermission('Book::', '::', ACCESS_READ)) {
            return LogUtil::registerPermissionError();
        }

        $render = Zikula_View::getInstance('Book', false);

        $return_text = "";
//now iterate through each chapter and call display_chapter
        $chapters = ModUtil::apiFunc('Book', 'user', 'getallchapters', array('bid' => $bid));
        foreach ($chapters as $chap_item) {
            if (SecurityUtil::checkPermission('Book::Chapter', "$bid::$chap_item[cid]", ACCESS_READ)) {
                $ret_text = $ret_text . pnModFunc('Book', 'user', 'displaychapter', array('cid' => $chap_item['cid']));
            }
        }
        return $ret_text;
    }

    /**
     * displaychapter
     *
     * Given a chapter id, display all the articles in the chapter
     * in succession. This is useful if one wants to have a printable version
     * There is a link to the printible version in the chapter.
     */
    public function displaychapter($args) {

// Get parameters
        $cid = FormUtil::getPassedValue('cid', isset($args['cid']) ? $args['cid'] : null);

        $render = Zikula_View::getInstance('Book', false);
// Load API.
//grab the chapter data
        $chapter = ModUtil::apiFunc('Book', 'user', 'getchapter', array('cid' => $cid));
        if (!SecurityUtil::checkPermission('Book::Chapter', "$chapter[bid]::$chapter[cid]", ACCESS_READ)) {
            return LogUtil::registerPermissionError();
        }
//grab all the articles and this time we do need the content
        $articles = ModUtil::apiFunc('Book', 'user', 'getallarticles', array('cid' => $cid));

        $render->assign('chapter_title', $chapter['name']);
        $render->assign('chapter_number', $chapter['number']);

        $article_name = array();
        $article_content = array();
        $article_number = array();

        foreach ($articles as $article_item) {
            if ($article_item['aid'] < 1) {
                continue;
            }
            $article_name[] = $article_item['title'];
            $article_number[] = $article_item['aid'];
            $article_content[] = $article_item['contents'];
            //we are going to view every article, so we want to increment
            //the counter. This may be too expensive.
            $article_item['counter']++;
            if (!ModUtil::apiFunc('Book', 'user', 'setcounter', array('aid' => $article_item['aid'], 'counter' => $article_item['counter']))) {
                return LogUtil::registerError(__("Could not set counter."));
            }
        }
        $render->assign('article_content', $article_content);
        $render->assign('article_number', $article_number);
        $render->assign('article_name', $article_name);

//process all inline figures.
        $return_text = $render->fetch('book_user_displaychapter.htm');
        $return_text = $this->addfigures($return_text);


        return $return_text;
    }

    public function displayarticlesinchapter($args) {
// Get parameters
        $cid = FormUtil::getPassedValue('cid', isset($args['cid']) ? $args['cid'] : null);

// Security check -
        if (!SecurityUtil::checkPermission('Book::', '::', ACCESS_OVERVIEW)) {
            return LogUtil::registerPermissionError();
        }

        $render = Zikula_View::getInstance('Book', false);

//grab the chapter data
        $chapter = ModUtil::apiFunc('Book', 'user', 'getchapter', array('cid' => $cid));
//grab all the articles and this time we do need the content
        $art_array = array();
        $articles = ModUtil::apiFunc('Book', 'user', 'getallarticles', array('cid' => $cid, 'get_content' => false));

        foreach ($articles as $article_item) {
            if ($article_item['aid'] > 0) {
                $art_array[] = $article_item;
            }
        }
        if (SecurityUtil::checkPermission('Book::Chapter', '.*::.*', ACCESS_ADMIN)) {
            $render->assign('show_internals', true);
        }

        $render->assign('chapter', $chapter);
        $render->assign('articles', $art_array);
        $render->caching = false;
        if (SecurityUtil::checkPermission('Book::Chapter', "$chapter[bid]::$cid", ACCESS_READ)) {
            return $render->fetch("book_user_toc_row.htm");
        }

        return $render->fetch("book_user_toc_row_overview.htm");
    }

    /**
     * dodef
     *
     * Given a word or two, check to see if it is in the glossary
     * and if not add it.
     */
    public function dodef() {
        $term = FormUtil::getPassedValue('text', isset($args['text']) ? $args['text'] : null);

//some quick checks
        $render = Zikula_View::getInstance('Book', false);
        $comment = "";

        if ($term == "") {
            $comment = __("No word was selected");
        } else {

            if (str_word_count($term) < 3) {
                if (pnUserLoggedIn()) {
                    $url = pnServerGetVar('HTTP_REFERER');
                    $user = UserUtil::getVar('uname');
                    //check to see that this user had not asked for more than 10 defs

                    $items = ModUtil::apiFunc('Book', 'user', 'getglossary', array('user' => $user));
                    if (count($items) < 11) {
                        //check to see if it is already defined.
                        $ispresent = ModUtil::apiFunc('Book', 'user', 'findglossaryterm', array('term' => $term));
                        if (!$ispresent) {
                            // The API function is called.
                            $gid = ModUtil::apiFunc('Book', 'admin', 'createglossary', array('term' => $term, 'definition' => "", 'url' => $url, 'user' => $user));

                            if ($gid != false) {
                                // Success
                                $comment = __('Thank you for submitting this word. The authors will define it soon.');
                            }
                        } else {
                            //if the book term is defined then redirect to that term.
                            //make all lowercase before making the url
                            $term = strtolower($term);
                            $url = pnModurl('Book', 'user', 'displayglossary') . "#$term";
                            pnRedirect($url);
                        }
                    } else {
                        $comment = __('You can only submit 10 words per user.');
                    }
                } else {
                    $comment = __('You need to be logged in to suggest words to define.');
                }
            } else {
                $comment = __('Phrases to define can be no longer that 3 words.');
            }
        }
//make sure that a glassary term is not already defined.
        $render->assign('comment', $comment);
        return $render->fetch('book_user_glossaddcomment.htm');
    }

    /**
     * collecthighlights
     *
     * Take all the highlights that a user has highlight for the book
     * and then display them to the user. This should be a useful study tool
     *
     */
    public function collecthighlights() {
//Find the current user ID
        $uid = UserUtil::getVar('uid');
        $cids = FormUtil::getPassedValue('cids', isset($args['cids']) ? $args['cids'] : null);

        $do_chaps = isset($cids);
//Check to make sure it is valid
        if ($uid == "") {
            //user id is empty, we are not in
            return LogUtil::registerError(__('You are not logged in. In this case you cannot add highlights.'));
        }

//get all the highligts for this user
        $highlights = ModUtil::apiFunc('Book', 'user', 'gethighlights', array('uid' => $uid));


//collect all the centents from the articles
//walk through each highlight and get the important information
        $highlight_text = array();
        $article_title = array();
        $article_chapter = array();
        $article_section = array();
        $aids = array();

        foreach ($highlights as $hItem) {
            //grab each article
            $article = ModUtil::apiFunc('Book', 'user', 'getarticle', array('aid' => $hItem['aid']));

            //now check for authorization, if not just continue. Frankly there should be none of these
            if (!SecurityUtil::checkPermission("Book::Chapter", "$article[bid]::$article[cid]", ACCESS_READ)) {
                continue;
            }

            //if we have the chapter array, then check to see
            //if we want to grab this chapter
            $chapter = ModUtil::apiFunc('Book', 'user', 'getchapter', array('cid' => $article[cid]));
            if ($do_chaps) {
                if (!in_array($chapter['number'], $cids)) {
                    continue;
                }
            }

            $article_chapter[] = $chapter['number'];
            //grab that portion of the article that is highlighted.
            $highlight_text[] = substr($article['contents'], $hItem['start'], $hItem['end'] - $hItem['start']);
            $article_title[] = $article['title'];
            $article_section[] = $article['aid'];
            $aids[] = $article['aid'];
        }

        $render = Zikula_View::getInstance('Book', false);
        $render->assign('aids', $aids);
        $render->assign('content', $highlight_text);
        $render->assign('title', $article_title);
        $render->assign('section', $article_section);
        $render->assign('chapter', $article_chapter);


        return $render->fetch('book_user_collecthighlights.htm');
    }

    /**
     * dohighlight
     *
     * The user has presumably selected some text. Change the highlight on it
     * so that it is yellow.
     */
    public function dohighlight() {
        $inText = FormUtil::getPassedValue('text', isset($args['text']) ? $args['text'] : null);
        $aid = FormUtil::getPassedValue('aid', isset($args['aid']) ? $args['aid'] : null);

//grab the user
        if ($inText == "") {
            return LogUtil::registerError(__('You can only highligh text in articles'));
        }
//Get the referring url
        $url = pnServerGetVar('HTTP_REFERER');
        if ($aid < 0) {
            return LogUtil::registerError(__('You can only highligh text in articles'));
        }


//grab the article to find the offsets
        $art_array = ModUtil::apiFunc('Book', 'user', 'getarticle', array('aid' => $aid));
//before doing anything else, make sure they are authorized to highlight.

        if (!SecurityUtil::checkPermission('Book::Chapter', "$art_array[bid]::$art_array[cid]", ACCESS_READ)) {
            return LogUtil::registerPermissionError();
        }
        $content = $art_array['contents'];

        $uid = UserUtil::getVar('uid');
        if ($uid == "") {
            //user id is empty, we are not in
            return LogUtil::registerError(__('You are not logged in. In this case you cannot add highlights.'));
        }

//find the offsets
//first extract the first three words and last three words of the
//incoming text
//get rid of any newlines in the content and in the in text.
        $content = preg_replace('/[\n|\r]/', ' ', $content);
        $inText = preg_replace('/[\n|\r]/', ' ', $inText);

        $string_words = explode(" ", $inText, 500);
//check to make sure the words are less than 500
        $words = count($string_words);
        if ($words > 499) {
            return LogUtil::registerError(__('The amount of text your are trying to highlight is too long'));
        }
//print $words;die;
        if ($words < 4) {
            return LogUtil::registerError(__('You must highlight at least four words.'));
        }
//get rid of any newlines in the content and in the in text.
        $size = strlen($content);
//print "original : $size\n <pre>$content</pre> <br />";
//This function removes all html code and replaces it with spaces.
        $pattern = "|<[^>]+>|U";
        $content = preg_replace_callback($pattern, "sub_html", $content);
        $size = strlen($content);
//print "substitute $size: \n <pre>$content</pre> <br />";
//create the pattern of the first three words.Note that the wildcard allow html to be in between.
        $inter_char = "[\s|\.|\?|\!]*?";
        $pattern = '/\s*?' . addcslashes($string_words[0], "()") . $inter_char . addcslashes($string_words[1], "()") . $inter_char . addcslashes($string_words[2], "()") . $inter_char . addcslashes($string_words[3], "()") . '/';
//print "Content: <br />$content<br />";
//print $pattern; die;

        $matches = array();
        preg_match($pattern, $content, $matches, PREG_OFFSET_CAPTURE);
        $start = $matches[0][1];
//now grab the ending text
        $pattern = '/' . $inter_char . addcslashes($string_words[$words - 4], "()") . $inter_char . addcslashes($string_words[$words - 3], "()") . $inter_char . addcslashes($string_words[$words - 2], "()") . $inter_char . addcslashes($string_words[$words - 1], "()") . '/';
        preg_match($pattern, $content, $matches, PREG_OFFSET_CAPTURE);
//you want the end of the match, preg_match send back the start of the match.
        $end = $matches[0][1] + strlen($matches[0][0]);
        if ($end == 0 || ($start > $end)) {
            //print "Start: $start, End: $end <br />";
            return LogUtil::registerError(__('You cannot highligh that text. Try a slightly different selection.') . "start:$start end:$end");
        }

//if there is a big gap between highlights, it may mean that
//we have an early match. try again to find a match later in the text..
        if ($end - $start > 3000) {
            $pattern = '/' . $inter_char . addslashes($string_words[0]) . $inter_char . addslashes($string_words[1]) . $inter_char . addslashes($string_words[2]) . $inter_char . addslashes($string_words[3]) . '/s';
            $matches = array();
            preg_match_all($pattern, $content, $matches, PREG_OFFSET_CAPTURE);
            $new_start = $matches[0][1][1];
            if ($new_start != 0) {
                $start = $new_start;
            }
        }

//finally make sure that this area is not already highlighted.
//if it is, unhighlight the area.
        $currentHighLights = ModUtil::apiFunc('book', 'user', 'gethighlights', array('uid' => $uid,
            'aid' => $aid));

        $recordHighlight = true;
        if ($currentHighLights) {
            //cycle through each highlight and see if we
            //already have it highlighted. If so, remove the highlight
            foreach ($currentHighLights as $hItem) {
                if (($start >= $hItem['start']) && ($start < $hItem['end'])) {
                    $recordHighlight = false;
                    //now put in a call to delete the highlight
                    $success = ModUtil::apiFunc('book', 'admin', 'deletehighlight', array('id' => $hItem['id']));
                    if (!$success) {
                        return DataUtil::formatForDisplayHTML("I was unable to delete that highlight");
                    } else {
                        //if we deleted a highlight, then we are done.
                        pnRedirect($url);
                        return true;
                    }
                }
            }
        }
        if (!$recordHighlight) {
            pnRedirect($url);
            return true;
        }

//record this in the database;
        if (!ModUtil::apiFunc('Book', 'admin', 'createhighlight', array('uid' => $uid,
                    'aid' => $aid,
                    'start' => $start,
                    'end' => $end))) {
            //set an error message and return false
            SessionUtil::setVar('error_msg', __('Highlighting failed.') . "dohighlight");
            return false;
        }
//finally redirect to the page again, this time with highlights
        pnRedirect($url);
        return true;
    }

    function sub_html($matches) {
//figure out the size of the match
        $count = strlen($matches[0]);
        $ret_text = "";
//now create a string with that many spaces
        for ($i = 0; $i < $count; $i++) {
            $ret_text .= " ";
        }
        return $ret_text;
    }

    /**
     * checkuserstatus
     *
     * A security function to ensure that no more than one or two sessions
     * are logged in using the same user id. If they are, two people are trying to
     * use the same account for access to the book.
     *
     * This funciton does make assumptions about the sessions table, but hopefully they
     * will hold for version 1.3.5. Right now, it looks like it will hold true
     * 
     * I cannot update to Doctrine yet in this function because the users module, where
     * I get this data is still not using doctrine. So I have to wait and use the old one
     */
    public function checkuserstatus() {

        if (!pnModGetVar('Book', 'securebooks')) {
            return;
        }

        if (pnUserLoggedIn()) {
            $uid = UserUtil::getVar('uid');
            $dbconn = & pnDBGetConn(true);
            $pntable = & DBUtil::getTables();
            $ipaddr = SessionUtil::getVar('ipaddr');

            $sessioninfocolumn = &$pntable['session_info_column'];
            $sessioninfotable = $pntable['session_info'];
            //use the time limit we use for killing a session.
            //This seems like a good number. After 10 min. they are
            //considered no readying anymore. Also, if two people
            //are trying to use the book with the same user name
            //them will get locked out for 10 min.
            $timelimit = (time() - (int) (pnConfigGetVar('secinactivemins') * 60));
            $where = "WHERE " . $sessioninfocolumn['uid'] . " = " . $uid . " AND " . $sessioninfocolumn['lastused'] . " > " . $timelimit;
            $result = DBUtil::selectObjectArray('session_info', $where);
            //only continue if there is no error
            $firstIp = false;
            if ($result !== false) {
                foreach ($result as $sesItem) {
                    // Obtain the ipaddr of the sessions that are active
                    if ($firstIp == false) {
                        $firstIp = $sesItem['ipaddr'];
                        continue;
                    }
                    //make sure they are all coming from the same computer,
                    //if not, log the user out.
                    if ($firstIp != $sesItem['ipaddr']) {
                        $url = pnModurl('book', 'user', 'morethanoneuser');
                        pnRedirect($url);
                        break;
                    }
                }
            }
        }
    }

    /**
     * morethanoneuser
     *
     * The user is cheating and more than one person are using the web site at the same time.
     * Send an explanation that this is the problem and then log them out.
     */
    public function morethanoneuser() {
        $render = Zikula_View::getInstance('Book', false);

        pnUserLogOut();
        return $render->fetch('book_user_morethanoneuser.htm');
    }
}

?>